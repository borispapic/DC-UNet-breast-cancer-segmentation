weights = model.get_weights()
weights_b = weights.copy()
#print(weights[0])
model1 = create_model((HEIGHT,WIDTH),checkpoint_epoch=CHECKPOINT_EP)
model1.load_weights('results\\weights.h5')
model1.compile(optimizer=Adam(1e-5), loss=iou_loss, metrics=[dice_coef, jacard, tversky, 'accuracy'])
weights_1 = model1.get_weights()
#print(np.shape(weights[0][0]))
#print('sledeci')
#print(np.shape(weights_1[0][0]))
#print(len(np.array(weights).reshape([-1])))
#print(np.testing.assert_array_equal(weights,weights))
for (layer,layer1) in zip(model.layers,model1.layers):
    result = np.array_equiv(layer.get_weights(),layer1.get_weights())
    #print(result)
    if result ==False:
        print('Faulty layer')
        print(np.array_equiv(layer.get_weights(), layer1.get_weights()))
        print(f"layer shapes: {np.shape(layer.get_weights())};{np.shape(layer1.get_weights())}")
        print(layer.get_config())
        print(layer1.get_config())
        #print(layer.get_config())
        #print(layer1.get_config())
        #print(np.shape(layer.get_weights()[0]))
        #print(np.shape(layer1.get_weights()[0]))
        result1 = np.array_equiv(layer.get_weights()[0], layer1.get_weights()[0])
        print(layer.get_weights()[0].shape)
        print(layer1.get_weights()[0].shape)
        print(layer.get_weights()[1].shape)
        print(layer1.get_weights()[1].shape)
        print(result1)
        result1 = np.array_equiv(layer.get_weights()[1], layer1.get_weights()[1])
        print(result1)
        #print('Previous layer')
        #print(previous_layer)
        #print(previous_layer1)
    previous_layer = layer.get_config()
    previous_layer1 = layer1.get_config()
averagek= []